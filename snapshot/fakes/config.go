// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"code.cloudfoundry.org/copilot/models"
	mcp "istio.io/api/mcp/v1alpha1"
)

type Config struct {
	CreateGatewayEnvelopesStub        func() []*mcp.Resource
	createGatewayEnvelopesMutex       sync.RWMutex
	createGatewayEnvelopesArgsForCall []struct{}
	createGatewayEnvelopesReturns     struct {
		result1 []*mcp.Resource
	}
	createGatewayEnvelopesReturnsOnCall map[int]struct {
		result1 []*mcp.Resource
	}
	CreateVirtualServiceEnvelopesStub        func(routes []*models.RouteWithBackends, version string) []*mcp.Resource
	createVirtualServiceEnvelopesMutex       sync.RWMutex
	createVirtualServiceEnvelopesArgsForCall []struct {
		routes  []*models.RouteWithBackends
		version string
	}
	createVirtualServiceEnvelopesReturns struct {
		result1 []*mcp.Resource
	}
	createVirtualServiceEnvelopesReturnsOnCall map[int]struct {
		result1 []*mcp.Resource
	}
	CreateDestinationRuleEnvelopesStub        func(routes []*models.RouteWithBackends, version string) []*mcp.Resource
	createDestinationRuleEnvelopesMutex       sync.RWMutex
	createDestinationRuleEnvelopesArgsForCall []struct {
		routes  []*models.RouteWithBackends
		version string
	}
	createDestinationRuleEnvelopesReturns struct {
		result1 []*mcp.Resource
	}
	createDestinationRuleEnvelopesReturnsOnCall map[int]struct {
		result1 []*mcp.Resource
	}
	CreateServiceEntryEnvelopesStub        func(routes []*models.RouteWithBackends, version string) []*mcp.Resource
	createServiceEntryEnvelopesMutex       sync.RWMutex
	createServiceEntryEnvelopesArgsForCall []struct {
		routes  []*models.RouteWithBackends
		version string
	}
	createServiceEntryEnvelopesReturns struct {
		result1 []*mcp.Resource
	}
	createServiceEntryEnvelopesReturnsOnCall map[int]struct {
		result1 []*mcp.Resource
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Config) CreateGatewayEnvelopes() []*mcp.Resource {
	fake.createGatewayEnvelopesMutex.Lock()
	ret, specificReturn := fake.createGatewayEnvelopesReturnsOnCall[len(fake.createGatewayEnvelopesArgsForCall)]
	fake.createGatewayEnvelopesArgsForCall = append(fake.createGatewayEnvelopesArgsForCall, struct{}{})
	fake.recordInvocation("CreateGatewayEnvelopes", []interface{}{})
	fake.createGatewayEnvelopesMutex.Unlock()
	if fake.CreateGatewayEnvelopesStub != nil {
		return fake.CreateGatewayEnvelopesStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createGatewayEnvelopesReturns.result1
}

func (fake *Config) CreateGatewayEnvelopesCallCount() int {
	fake.createGatewayEnvelopesMutex.RLock()
	defer fake.createGatewayEnvelopesMutex.RUnlock()
	return len(fake.createGatewayEnvelopesArgsForCall)
}

func (fake *Config) CreateGatewayEnvelopesReturns(result1 []*mcp.Resource) {
	fake.CreateGatewayEnvelopesStub = nil
	fake.createGatewayEnvelopesReturns = struct {
		result1 []*mcp.Resource
	}{result1}
}

func (fake *Config) CreateGatewayEnvelopesReturnsOnCall(i int, result1 []*mcp.Resource) {
	fake.CreateGatewayEnvelopesStub = nil
	if fake.createGatewayEnvelopesReturnsOnCall == nil {
		fake.createGatewayEnvelopesReturnsOnCall = make(map[int]struct {
			result1 []*mcp.Resource
		})
	}
	fake.createGatewayEnvelopesReturnsOnCall[i] = struct {
		result1 []*mcp.Resource
	}{result1}
}

func (fake *Config) CreateVirtualServiceEnvelopes(routes []*models.RouteWithBackends, version string) []*mcp.Resource {
	var routesCopy []*models.RouteWithBackends
	if routes != nil {
		routesCopy = make([]*models.RouteWithBackends, len(routes))
		copy(routesCopy, routes)
	}
	fake.createVirtualServiceEnvelopesMutex.Lock()
	ret, specificReturn := fake.createVirtualServiceEnvelopesReturnsOnCall[len(fake.createVirtualServiceEnvelopesArgsForCall)]
	fake.createVirtualServiceEnvelopesArgsForCall = append(fake.createVirtualServiceEnvelopesArgsForCall, struct {
		routes  []*models.RouteWithBackends
		version string
	}{routesCopy, version})
	fake.recordInvocation("CreateVirtualServiceEnvelopes", []interface{}{routesCopy, version})
	fake.createVirtualServiceEnvelopesMutex.Unlock()
	if fake.CreateVirtualServiceEnvelopesStub != nil {
		return fake.CreateVirtualServiceEnvelopesStub(routes, version)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createVirtualServiceEnvelopesReturns.result1
}

func (fake *Config) CreateVirtualServiceEnvelopesCallCount() int {
	fake.createVirtualServiceEnvelopesMutex.RLock()
	defer fake.createVirtualServiceEnvelopesMutex.RUnlock()
	return len(fake.createVirtualServiceEnvelopesArgsForCall)
}

func (fake *Config) CreateVirtualServiceEnvelopesArgsForCall(i int) ([]*models.RouteWithBackends, string) {
	fake.createVirtualServiceEnvelopesMutex.RLock()
	defer fake.createVirtualServiceEnvelopesMutex.RUnlock()
	return fake.createVirtualServiceEnvelopesArgsForCall[i].routes, fake.createVirtualServiceEnvelopesArgsForCall[i].version
}

func (fake *Config) CreateVirtualServiceEnvelopesReturns(result1 []*mcp.Resource) {
	fake.CreateVirtualServiceEnvelopesStub = nil
	fake.createVirtualServiceEnvelopesReturns = struct {
		result1 []*mcp.Resource
	}{result1}
}

func (fake *Config) CreateVirtualServiceEnvelopesReturnsOnCall(i int, result1 []*mcp.Resource) {
	fake.CreateVirtualServiceEnvelopesStub = nil
	if fake.createVirtualServiceEnvelopesReturnsOnCall == nil {
		fake.createVirtualServiceEnvelopesReturnsOnCall = make(map[int]struct {
			result1 []*mcp.Resource
		})
	}
	fake.createVirtualServiceEnvelopesReturnsOnCall[i] = struct {
		result1 []*mcp.Resource
	}{result1}
}

func (fake *Config) CreateDestinationRuleEnvelopes(routes []*models.RouteWithBackends, version string) []*mcp.Resource {
	var routesCopy []*models.RouteWithBackends
	if routes != nil {
		routesCopy = make([]*models.RouteWithBackends, len(routes))
		copy(routesCopy, routes)
	}
	fake.createDestinationRuleEnvelopesMutex.Lock()
	ret, specificReturn := fake.createDestinationRuleEnvelopesReturnsOnCall[len(fake.createDestinationRuleEnvelopesArgsForCall)]
	fake.createDestinationRuleEnvelopesArgsForCall = append(fake.createDestinationRuleEnvelopesArgsForCall, struct {
		routes  []*models.RouteWithBackends
		version string
	}{routesCopy, version})
	fake.recordInvocation("CreateDestinationRuleEnvelopes", []interface{}{routesCopy, version})
	fake.createDestinationRuleEnvelopesMutex.Unlock()
	if fake.CreateDestinationRuleEnvelopesStub != nil {
		return fake.CreateDestinationRuleEnvelopesStub(routes, version)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createDestinationRuleEnvelopesReturns.result1
}

func (fake *Config) CreateDestinationRuleEnvelopesCallCount() int {
	fake.createDestinationRuleEnvelopesMutex.RLock()
	defer fake.createDestinationRuleEnvelopesMutex.RUnlock()
	return len(fake.createDestinationRuleEnvelopesArgsForCall)
}

func (fake *Config) CreateDestinationRuleEnvelopesArgsForCall(i int) ([]*models.RouteWithBackends, string) {
	fake.createDestinationRuleEnvelopesMutex.RLock()
	defer fake.createDestinationRuleEnvelopesMutex.RUnlock()
	return fake.createDestinationRuleEnvelopesArgsForCall[i].routes, fake.createDestinationRuleEnvelopesArgsForCall[i].version
}

func (fake *Config) CreateDestinationRuleEnvelopesReturns(result1 []*mcp.Resource) {
	fake.CreateDestinationRuleEnvelopesStub = nil
	fake.createDestinationRuleEnvelopesReturns = struct {
		result1 []*mcp.Resource
	}{result1}
}

func (fake *Config) CreateDestinationRuleEnvelopesReturnsOnCall(i int, result1 []*mcp.Resource) {
	fake.CreateDestinationRuleEnvelopesStub = nil
	if fake.createDestinationRuleEnvelopesReturnsOnCall == nil {
		fake.createDestinationRuleEnvelopesReturnsOnCall = make(map[int]struct {
			result1 []*mcp.Resource
		})
	}
	fake.createDestinationRuleEnvelopesReturnsOnCall[i] = struct {
		result1 []*mcp.Resource
	}{result1}
}

func (fake *Config) CreateServiceEntryEnvelopes(routes []*models.RouteWithBackends, version string) []*mcp.Resource {
	var routesCopy []*models.RouteWithBackends
	if routes != nil {
		routesCopy = make([]*models.RouteWithBackends, len(routes))
		copy(routesCopy, routes)
	}
	fake.createServiceEntryEnvelopesMutex.Lock()
	ret, specificReturn := fake.createServiceEntryEnvelopesReturnsOnCall[len(fake.createServiceEntryEnvelopesArgsForCall)]
	fake.createServiceEntryEnvelopesArgsForCall = append(fake.createServiceEntryEnvelopesArgsForCall, struct {
		routes  []*models.RouteWithBackends
		version string
	}{routesCopy, version})
	fake.recordInvocation("CreateServiceEntryEnvelopes", []interface{}{routesCopy, version})
	fake.createServiceEntryEnvelopesMutex.Unlock()
	if fake.CreateServiceEntryEnvelopesStub != nil {
		return fake.CreateServiceEntryEnvelopesStub(routes, version)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createServiceEntryEnvelopesReturns.result1
}

func (fake *Config) CreateServiceEntryEnvelopesCallCount() int {
	fake.createServiceEntryEnvelopesMutex.RLock()
	defer fake.createServiceEntryEnvelopesMutex.RUnlock()
	return len(fake.createServiceEntryEnvelopesArgsForCall)
}

func (fake *Config) CreateServiceEntryEnvelopesArgsForCall(i int) ([]*models.RouteWithBackends, string) {
	fake.createServiceEntryEnvelopesMutex.RLock()
	defer fake.createServiceEntryEnvelopesMutex.RUnlock()
	return fake.createServiceEntryEnvelopesArgsForCall[i].routes, fake.createServiceEntryEnvelopesArgsForCall[i].version
}

func (fake *Config) CreateServiceEntryEnvelopesReturns(result1 []*mcp.Resource) {
	fake.CreateServiceEntryEnvelopesStub = nil
	fake.createServiceEntryEnvelopesReturns = struct {
		result1 []*mcp.Resource
	}{result1}
}

func (fake *Config) CreateServiceEntryEnvelopesReturnsOnCall(i int, result1 []*mcp.Resource) {
	fake.CreateServiceEntryEnvelopesStub = nil
	if fake.createServiceEntryEnvelopesReturnsOnCall == nil {
		fake.createServiceEntryEnvelopesReturnsOnCall = make(map[int]struct {
			result1 []*mcp.Resource
		})
	}
	fake.createServiceEntryEnvelopesReturnsOnCall[i] = struct {
		result1 []*mcp.Resource
	}{result1}
}

func (fake *Config) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createGatewayEnvelopesMutex.RLock()
	defer fake.createGatewayEnvelopesMutex.RUnlock()
	fake.createVirtualServiceEnvelopesMutex.RLock()
	defer fake.createVirtualServiceEnvelopesMutex.RUnlock()
	fake.createDestinationRuleEnvelopesMutex.RLock()
	defer fake.createDestinationRuleEnvelopesMutex.RUnlock()
	fake.createServiceEntryEnvelopesMutex.RLock()
	defer fake.createServiceEntryEnvelopesMutex.RUnlock()
	return fake.invocations
}

func (fake *Config) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
