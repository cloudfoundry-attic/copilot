// Code generated by counterfeiter. DO NOT EDIT.
package monitorfakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/bbs/db/sqldb/helpers/monitor"
)

type FakeMonitor struct {
	MonitorStub        func(func() error) error
	monitorMutex       sync.RWMutex
	monitorArgsForCall []struct {
		arg1 func() error
	}
	monitorReturns struct {
		result1 error
	}
	monitorReturnsOnCall map[int]struct {
		result1 error
	}
	TotalStub        func() int64
	totalMutex       sync.RWMutex
	totalArgsForCall []struct{}
	totalReturns     struct {
		result1 int64
	}
	totalReturnsOnCall map[int]struct {
		result1 int64
	}
	SucceededStub        func() int64
	succeededMutex       sync.RWMutex
	succeededArgsForCall []struct{}
	succeededReturns     struct {
		result1 int64
	}
	succeededReturnsOnCall map[int]struct {
		result1 int64
	}
	FailedStub        func() int64
	failedMutex       sync.RWMutex
	failedArgsForCall []struct{}
	failedReturns     struct {
		result1 int64
	}
	failedReturnsOnCall map[int]struct {
		result1 int64
	}
	ReadAndResetDurationMaxStub        func() time.Duration
	readAndResetDurationMaxMutex       sync.RWMutex
	readAndResetDurationMaxArgsForCall []struct{}
	readAndResetDurationMaxReturns     struct {
		result1 time.Duration
	}
	readAndResetDurationMaxReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	ReadAndResetInFlightMaxStub        func() int64
	readAndResetInFlightMaxMutex       sync.RWMutex
	readAndResetInFlightMaxArgsForCall []struct{}
	readAndResetInFlightMaxReturns     struct {
		result1 int64
	}
	readAndResetInFlightMaxReturnsOnCall map[int]struct {
		result1 int64
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeMonitor) Monitor(arg1 func() error) error {
	fake.monitorMutex.Lock()
	ret, specificReturn := fake.monitorReturnsOnCall[len(fake.monitorArgsForCall)]
	fake.monitorArgsForCall = append(fake.monitorArgsForCall, struct {
		arg1 func() error
	}{arg1})
	fake.recordInvocation("Monitor", []interface{}{arg1})
	fake.monitorMutex.Unlock()
	if fake.MonitorStub != nil {
		return fake.MonitorStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.monitorReturns.result1
}

func (fake *FakeMonitor) MonitorCallCount() int {
	fake.monitorMutex.RLock()
	defer fake.monitorMutex.RUnlock()
	return len(fake.monitorArgsForCall)
}

func (fake *FakeMonitor) MonitorArgsForCall(i int) func() error {
	fake.monitorMutex.RLock()
	defer fake.monitorMutex.RUnlock()
	return fake.monitorArgsForCall[i].arg1
}

func (fake *FakeMonitor) MonitorReturns(result1 error) {
	fake.MonitorStub = nil
	fake.monitorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMonitor) MonitorReturnsOnCall(i int, result1 error) {
	fake.MonitorStub = nil
	if fake.monitorReturnsOnCall == nil {
		fake.monitorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.monitorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMonitor) Total() int64 {
	fake.totalMutex.Lock()
	ret, specificReturn := fake.totalReturnsOnCall[len(fake.totalArgsForCall)]
	fake.totalArgsForCall = append(fake.totalArgsForCall, struct{}{})
	fake.recordInvocation("Total", []interface{}{})
	fake.totalMutex.Unlock()
	if fake.TotalStub != nil {
		return fake.TotalStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.totalReturns.result1
}

func (fake *FakeMonitor) TotalCallCount() int {
	fake.totalMutex.RLock()
	defer fake.totalMutex.RUnlock()
	return len(fake.totalArgsForCall)
}

func (fake *FakeMonitor) TotalReturns(result1 int64) {
	fake.TotalStub = nil
	fake.totalReturns = struct {
		result1 int64
	}{result1}
}

func (fake *FakeMonitor) TotalReturnsOnCall(i int, result1 int64) {
	fake.TotalStub = nil
	if fake.totalReturnsOnCall == nil {
		fake.totalReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.totalReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *FakeMonitor) Succeeded() int64 {
	fake.succeededMutex.Lock()
	ret, specificReturn := fake.succeededReturnsOnCall[len(fake.succeededArgsForCall)]
	fake.succeededArgsForCall = append(fake.succeededArgsForCall, struct{}{})
	fake.recordInvocation("Succeeded", []interface{}{})
	fake.succeededMutex.Unlock()
	if fake.SucceededStub != nil {
		return fake.SucceededStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.succeededReturns.result1
}

func (fake *FakeMonitor) SucceededCallCount() int {
	fake.succeededMutex.RLock()
	defer fake.succeededMutex.RUnlock()
	return len(fake.succeededArgsForCall)
}

func (fake *FakeMonitor) SucceededReturns(result1 int64) {
	fake.SucceededStub = nil
	fake.succeededReturns = struct {
		result1 int64
	}{result1}
}

func (fake *FakeMonitor) SucceededReturnsOnCall(i int, result1 int64) {
	fake.SucceededStub = nil
	if fake.succeededReturnsOnCall == nil {
		fake.succeededReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.succeededReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *FakeMonitor) Failed() int64 {
	fake.failedMutex.Lock()
	ret, specificReturn := fake.failedReturnsOnCall[len(fake.failedArgsForCall)]
	fake.failedArgsForCall = append(fake.failedArgsForCall, struct{}{})
	fake.recordInvocation("Failed", []interface{}{})
	fake.failedMutex.Unlock()
	if fake.FailedStub != nil {
		return fake.FailedStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.failedReturns.result1
}

func (fake *FakeMonitor) FailedCallCount() int {
	fake.failedMutex.RLock()
	defer fake.failedMutex.RUnlock()
	return len(fake.failedArgsForCall)
}

func (fake *FakeMonitor) FailedReturns(result1 int64) {
	fake.FailedStub = nil
	fake.failedReturns = struct {
		result1 int64
	}{result1}
}

func (fake *FakeMonitor) FailedReturnsOnCall(i int, result1 int64) {
	fake.FailedStub = nil
	if fake.failedReturnsOnCall == nil {
		fake.failedReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.failedReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *FakeMonitor) ReadAndResetDurationMax() time.Duration {
	fake.readAndResetDurationMaxMutex.Lock()
	ret, specificReturn := fake.readAndResetDurationMaxReturnsOnCall[len(fake.readAndResetDurationMaxArgsForCall)]
	fake.readAndResetDurationMaxArgsForCall = append(fake.readAndResetDurationMaxArgsForCall, struct{}{})
	fake.recordInvocation("ReadAndResetDurationMax", []interface{}{})
	fake.readAndResetDurationMaxMutex.Unlock()
	if fake.ReadAndResetDurationMaxStub != nil {
		return fake.ReadAndResetDurationMaxStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.readAndResetDurationMaxReturns.result1
}

func (fake *FakeMonitor) ReadAndResetDurationMaxCallCount() int {
	fake.readAndResetDurationMaxMutex.RLock()
	defer fake.readAndResetDurationMaxMutex.RUnlock()
	return len(fake.readAndResetDurationMaxArgsForCall)
}

func (fake *FakeMonitor) ReadAndResetDurationMaxReturns(result1 time.Duration) {
	fake.ReadAndResetDurationMaxStub = nil
	fake.readAndResetDurationMaxReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeMonitor) ReadAndResetDurationMaxReturnsOnCall(i int, result1 time.Duration) {
	fake.ReadAndResetDurationMaxStub = nil
	if fake.readAndResetDurationMaxReturnsOnCall == nil {
		fake.readAndResetDurationMaxReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.readAndResetDurationMaxReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeMonitor) ReadAndResetInFlightMax() int64 {
	fake.readAndResetInFlightMaxMutex.Lock()
	ret, specificReturn := fake.readAndResetInFlightMaxReturnsOnCall[len(fake.readAndResetInFlightMaxArgsForCall)]
	fake.readAndResetInFlightMaxArgsForCall = append(fake.readAndResetInFlightMaxArgsForCall, struct{}{})
	fake.recordInvocation("ReadAndResetInFlightMax", []interface{}{})
	fake.readAndResetInFlightMaxMutex.Unlock()
	if fake.ReadAndResetInFlightMaxStub != nil {
		return fake.ReadAndResetInFlightMaxStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.readAndResetInFlightMaxReturns.result1
}

func (fake *FakeMonitor) ReadAndResetInFlightMaxCallCount() int {
	fake.readAndResetInFlightMaxMutex.RLock()
	defer fake.readAndResetInFlightMaxMutex.RUnlock()
	return len(fake.readAndResetInFlightMaxArgsForCall)
}

func (fake *FakeMonitor) ReadAndResetInFlightMaxReturns(result1 int64) {
	fake.ReadAndResetInFlightMaxStub = nil
	fake.readAndResetInFlightMaxReturns = struct {
		result1 int64
	}{result1}
}

func (fake *FakeMonitor) ReadAndResetInFlightMaxReturnsOnCall(i int, result1 int64) {
	fake.ReadAndResetInFlightMaxStub = nil
	if fake.readAndResetInFlightMaxReturnsOnCall == nil {
		fake.readAndResetInFlightMaxReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.readAndResetInFlightMaxReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *FakeMonitor) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.monitorMutex.RLock()
	defer fake.monitorMutex.RUnlock()
	fake.totalMutex.RLock()
	defer fake.totalMutex.RUnlock()
	fake.succeededMutex.RLock()
	defer fake.succeededMutex.RUnlock()
	fake.failedMutex.RLock()
	defer fake.failedMutex.RUnlock()
	fake.readAndResetDurationMaxMutex.RLock()
	defer fake.readAndResetDurationMaxMutex.RUnlock()
	fake.readAndResetInFlightMaxMutex.RLock()
	defer fake.readAndResetInFlightMaxMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeMonitor) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ monitor.Monitor = new(FakeMonitor)
